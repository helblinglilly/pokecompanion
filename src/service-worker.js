import { build, files, version } from '$service-worker';

// https://github.com/microsoft/TypeScript/issues/11781 - this is needed for TS and ESLint

/// env serviceworker
const globalThis = /** @type {unknown} */ (self);
/// <reference no-default-lib="true"/>
/// <reference lib="es2020" />
/// <reference lib="WebWorker" />
const sw = /** @type {ServiceWorkerGlobalScope & typeof globalThis} */ (globalThis);

const ASSETS = `assets-${version}`;
const REQUESTS = `requests-${version}`;

// Cache size limits (in bytes)
const MAX_CACHE_SIZE = 50 * 1024 * 1024; // 50MB
const MAX_ENTRIES_PER_CACHE = 200;

// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const staticAssets = build.concat(files);
const staticAssetUrls = staticAssets.map((a) => self.location.origin + a);

/**
 * Get the estimated size of a cache
 * @param {Cache} cache
 */
async function getCacheSize(cache) {
	const keys = await cache.keys();
	let totalSize = 0;

	for (const request of keys) {
		const response = await cache.match(request);
		if (response) {
			const clone = response.clone();
			const buffer = await clone.arrayBuffer();
			totalSize += buffer.byteLength;
		}
	}

	return { size: totalSize, count: keys.length };
}

/**
 * Clean up cache if it exceeds limits
 * @param {string} cacheName
 */
async function cleanupCache(cacheName) {
	const cache = await caches.open(cacheName);
	const { size, count } = await getCacheSize(cache);

	if (size > MAX_CACHE_SIZE || count > MAX_ENTRIES_PER_CACHE) {
		console.log(`Cache ${cacheName} exceeds limits (${size} bytes, ${count} entries). Cleaning up...`);

		const keys = await cache.keys();
		// Sort by URL to have a consistent cleanup strategy
		keys.sort((a, b) => a.url.localeCompare(b.url));

		// Remove oldest entries (first 25% of entries)
		const entriesToRemove = Math.floor(keys.length * 0.25);
		for (let i = 0; i < entriesToRemove && i < keys.length; i++) {
			await cache.delete(keys[i]);
		}

		console.log(`Cleaned up ${entriesToRemove} entries from ${cacheName}`);
	}
}

/**
 * Safe cache put with quota handling
 * @param {Cache} cache
 * @param {RequestInfo} request
 * @param {Response} response
 */
async function safeCachePut(cache, request, response) {
	try {
		await cache.put(request, response);
	} catch (error) {
		if (error.name === 'QuotaExceededError') {
			console.log('Quota exceeded, attempting cache cleanup...');

			// Try to clean up the specific cache
			const cacheName = cache instanceof Cache ? REQUESTS : cache;
			await cleanupCache(cacheName);

			// Try again after cleanup
			try {
				await cache.put(request, response);
				console.log('Successfully cached after cleanup');
			} catch (secondError) {
				console.warn('Still unable to cache after cleanup:', secondError);
			}
		} else {
			throw error;
		}
	}
}

/** @param {ExtendableEvent} event */
function install_listener(event) {
	try {
		event.waitUntil(
			caches
				.open(ASSETS)
				.then(async (cache) => {
					try {
						// Add static assets in smaller batches to avoid quota issues
						const batchSize = 10;
						for (let i = 0; i < staticAssets.length; i += batchSize) {
							const batch = staticAssets.slice(i, i + batchSize);
							await cache.addAll(batch);
						}
						console.log(`Successfully cached ${staticAssets.length} static assets`);
					} catch (err) {
						console.log(`Failed to add assets to static cache - ${err}`);
						// Try to add assets one by one
						for (const asset of staticAssets) {
							try {
								const response = await fetch(asset);
								await safeCachePut(cache, asset, response);
							} catch (individualError) {
								console.warn(`Failed to cache individual asset ${asset}:`, individualError);
							}
						}
					}
				})
				.catch((err) => {
					console.error('Error during installation:', err);
				})
		);
	} catch (err) {
		console.error('Error when installing service worker:', err);
	}
}

/** @param {ExtendableEvent} event */
function activate_listener(event) {
	try {
		event.waitUntil(
			caches.keys().then(async (keys) => {
				for (const key of keys) {
					if (key !== ASSETS && key !== REQUESTS) {
						await caches.delete(key);
					}
				}

				// Clean up current caches if they're too large
				await cleanupCache(ASSETS);
				await cleanupCache(REQUESTS);

				sw.clients.claim();
			})
		);
	} catch (err) {
		console.error('Error when activating service worker listener:', err);
		throw err;
	}
}

/**
 * Fetch the asset from the network and store it in the cache.
 * Fall back to the cache if the user is offline.
 * @param {RequestInfo} request
 * @param {string} cacheName
 */
async function networkFirst(request, cacheName = REQUESTS) {
	const cache = await caches.open(cacheName);

	try {
		const response = await fetch(request);

		if (response.status < 400) {
			await safeCachePut(cache, request, response.clone());
		}

		return response;
	} catch (err) {
		const cachedResponse = await cache.match(request);

		if (cachedResponse) {
			return cachedResponse;
		}

		if (!navigator.onLine) {
			return new Response('You are offline', {
				status: 523,
				statusText: 'Requested an online resource while offline'
			});
		}

		throw err;
	}
}

/**
 * Try to load an object from cache first, fall back to the network and cache it then
 * @param {RequestInfo} request
 */
async function cacheFirst(request, cacheName = REQUESTS) {
	const cache = await caches.open(cacheName);
	const cachedResponse = await cache.match(request);

	if (cachedResponse) {
		// Check if the cached response is older than 30 minutes (fixed the duration)
		const cacheAge = Date.now() - new Date(cachedResponse.headers.get('date')).getTime();
		const thirtyMinutes = 30 * 60 * 1000; // Fixed: was 3 days, now actually 30 minutes

		if (cacheAge > thirtyMinutes) {
			try {
				await cache.delete(request);

				const networkResponse = await fetch(request);
				console.log('updating cached entry for', request);
				if (networkResponse.status < 400) {
					await safeCachePut(cache, request, networkResponse.clone());
				}
				return networkResponse;
			} catch (err) {
				return new Response(JSON.stringify({ error: 'Failed to connect to server' }), {
					status: 503,
					statusText: 'Failed to connect to server',
					headers: { 'Content-Type': 'application/json' }
				});
			}
		}

		return cachedResponse;
	}

	if (!navigator.onLine) {
		return new Response(JSON.stringify({ error: 'Requested an online resource while offline' }), {
			status: 523,
			statusText: 'Requested an online resource while offline',
			headers: { 'Content-Type': 'application/json' }
		});
	}

	try {
		const networkResponse = await fetch(request);
		if (networkResponse.status < 400) {
			await safeCachePut(cache, request, networkResponse.clone());
		}
		return networkResponse;
	} catch (err) {
		return new Response(JSON.stringify({ error: 'Failed to connect to server' }), {
			status: 503,
			statusText: 'Failed to connect to server',
			headers: { 'Content-Type': 'application/json' }
		});
	}
}

async function networkOnly(request) {
	if (!navigator.onLine) {
		return new Response(JSON.stringify({ error: 'Requested an online resource while offline' }), {
			status: 523,
			statusText: 'Requested an online resource while offline',
			headers: { 'Content-Type': 'application/json' }
		});
	}
	try {
		return await fetch(request);
	} catch (err) {
		console.log('error in network only', err);
		throw err;
	}
}

/** @param {FetchEvent} event */
async function fetch_listener(event) {
	const request = event.request;
	const url = new URL(request.url);

	// Don't cache any non-get requests
	if (event.request.method !== 'GET') {
		event.respondWith(networkOnly(request));
		return;
	}

	// Serve any static assets from cache first
	if (staticAssetUrls.includes(url.href)) {
		event.respondWith(cacheFirst(request, ASSETS));
		return;
	}

	// Always serve pokeapi from cache first
	if (url.hostname === 'pokeapi.co' || url.hostname === 'raw.githubusercontent.com') {
		event.respondWith(cacheFirst(request, REQUESTS));
		return;
	}

	if (url.hostname === self.location.hostname) {
		// Never cache protected routes
		if (
			url.pathname.includes('/auth/') ||
			url.pathname.includes('/api/log') ||
			url.pathname.includes('/user/')
		) {
			event.respondWith(networkOnly(request));
			return;
		}

		if (
			url.pathname.startsWith('/src/lib/data') ||
			url.pathname.startsWith('/api/pokemon')
		) {
			event.respondWith(cacheFirst(request));
			return;
		}
		// Try to get every other request fresh first - search should be cached in the future
		event.respondWith(networkFirst(request, REQUESTS));
		return;
	}

	event.respondWith(networkFirst(request, REQUESTS));
}

try {
	sw.addEventListener('install', install_listener);
	sw.addEventListener('activate', activate_listener);
	sw.addEventListener('fetch', fetch_listener);
} catch (err) {
	console.log(`failed to add event listeners with error`, err);
	throw err;
}
